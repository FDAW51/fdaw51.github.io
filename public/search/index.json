[{"content":"摘要： 本文系统探讨了统计物理模型与神经计算理论之间的深刻联系，阐述了基于“能量最小化”原理的计算框架如何从物理系统延伸至生物智能。\n文章首先回顾了Ising模型及其哈密顿量形式，并以此为基础介绍了**模拟退火（Simulated Annealing）与量子退火（Quantum Annealing）**算法。通过类比物理系统寻找最低能态的过程，解释了如何利用热涨落和量子隧穿效应克服局部极小值，从而解决复杂的组合优化问题（如NP问题）。\n随后，文章将物理自旋映射为神经元，引入了Hopfield神经网络。基于Hebbian学习规则，文章展示了神经网络的记忆存储与提取本质上是在塑造能量地貌（Energy Landscape），即通过突触权重的调整使得记忆状态对应于系统的能量基态。\n最后，针对传统Hebbian学习缺乏全局误差传导机制（信用分配问题）的局限，文章重点介绍了**预测编码（Predictive Coding, PC）理论。作为神经科学的前沿理论，PC通过构建分层高斯生成模型，引入了“状态单元”与“误差单元”的双重结构。文章详细推导了PC的自由能函数及动力学方程，揭示了大脑如何通过快速的神经元状态更新（感知推断）与慢速的突触权重更新（学习）**来最小化预测误差。结论指出，Predictive Coding在保持局部计算（生物学合理性）的同时，实现了类似反向传播的深度误差修正能力，为理解大脑的高级认知功能提供了强有力的数学解释。\n关键词： Ising模型，模拟退火，量子退火，Hopfield网络，Hebbian学习，预测编码 (Predictive Coding)，自由能原理，能量地貌\n1.Ising Model 基本概念：统计物理中用于描述铁磁性的数学模型。系统由许多离散变量（自旋）组成，每个自选变量的取值为 $+1$ 或 $-1$。\n哈密顿量 (能量函数)：\n$$H(\\sigma) = -\\sum_{\u0026lt;i,j\u0026gt;} J_{ij} \\sigma_i \\sigma_j - \\mu \\sum_{j} h_j \\sigma_j$$\n其中 $J_{ij}$ 代表每个自旋之间的相互作用强度，$h_j$ 代表外部磁场。第一项是相互作用能，第二项是外部磁场的能量。 通过这个哈密顿量，就可以研究这个系统的相变过程以及其相变温度Tc。 2. 模拟退火算法（Simulated annealing） 解决的问题： 优化问题经常出现在我们的生活当中，比如：\n如何在最短的时间内到达学校？ 如何以最低的价格买到想要购买的东西？ 如何选择合适的路线使得行驶的距离最短？ 这些问题在我们生活中其实不知不觉地在被解决，比如导航的app，购物的app，都无时无刻地在计算对于一类优化问题的最优解。\n那么它们是如何来解决优化问题的呢？\n物理上的启发： 首先，一个优化问题可以转化成，假如你在一群山之间，这些山的高度不一样，你如何找到这群山中最低的地方。从物理的角度上说，就是如何找到一个能量（势能）最低点。\n模拟退火算法就是物理学家类比固体退火过程得出的。\n固体在温度比较高的时候，此时固体内部的原子剧烈运动（热运动剧烈的程度与温度相关），逐渐降温（退火过程）整个系统接近平衡，最终就会达到一个平衡态，这个平衡态的能量最低。\n其中，固体在温度T时处于能量E的状态的概率遵循Boltzmann分布： $$ P(E) \\propto e^{-E/(kT)} $$ 那么物理学家就将这么一个过程类比到一个优化问题：\n将一个物理系统的能量类比为优化问题的目标函数 $f(x)$。 温度T类比为在寻找最优解过程中“容忍坏解”的程度。 物理系统的状态类比为优化问题的一个候选解。 物理系统遵循Boltzmann分布的特性类比为优化问题中不同解之间的转变规则。 具体算法： 对于一个优化问题 $\\bold{min}_x f(x)$,f(x)是目标函数。\n模拟退火算法的流程如下：\n随机初始化一个解 $f(x_0)$\n在当前解附近 生成一个新解 f(x)\n根据能量变化 ΔE =f(x)-f(x0) 来决定是否接受新解：\n若更好（ΔE \u0026lt; 0）：必然接受\n若更差（ΔE \u0026gt; 0）：以概率 $$ P = \\exp(-\\Delta E / T) $$ 接受\n逐渐降低温度 T\n当温度很低时系统趋于稳定，返回最终解\n那么其中有一个问题？\n在算法的第二步中，如何选择/生成这样一个新解？（解决方案：随机生成但是随着温度的下降随机性变小。） 3 .量子退火算法 首先，在经典中，想要找到全局的最优解需要翻过一些山峰。\n但是在量子中有一个著名的效应是量子隧穿效应，也就是说，当这个小球面对一个山峰时，它有概率直接穿过到达这座山的另一侧。\n那么这样一种神奇的效应正好可以克服经典模拟退火算法容易陷入局部最优解的问题，它使得候选解可以更快地离开局部最优。\nIsing model的引入 在组合优化问题中有这样一条定理：\n任意NP类型组合优化问题（SAT、Max-Cut、TSP、Partition、QUBO…） 其目标函数都可以转成 二值变量的二次型： $$ E(x) = x^T Q x $$ 其中 $x_i \\in {0,1}$ 或 $x_i=\\pm1$。\n而Ising model的哈密顿量： $$ H = -\\sum_{i\u0026lt;j} J_{ij} \\sigma_i^z \\sigma_j^z - \\sum_i h_i \\sigma_i^z $$ 可以发现，Ising model中的能量函数与组合优化问题中二值变量的二次型类似，其中自旋的取值为正负1。因此可以通过Ising model 的哈密顿量来表达所有NP类型的组合问题的哈密顿量。\n具体流程 首先我们将目标函数类比为经典Ising model的哈密顿量：经典 Ising 哈密顿量（目标函数）： $$ H_C = -\\sum_{i\u0026lt;j} J_{ij} \\sigma_i^z \\sigma_j^z - \\sum_i h_i \\sigma_i^z $$ 其中：\n$\\sigma_i^z$ 是 Pauli Z 矩阵 自旋向上对应 $s_i = +1$，向下对应 $s_i = -1$ 然后我们加入一个量子涨落（一个外部的扰动/影响），使得整个系统可以进行量子隧穿： $$ H_D = -\\Gamma \\sum_i \\sigma_i^x $$ 其中：\n$\\sigma_i^x$ 会翻转自旋（量子涨落） $\\Gamma$ 是横场强度（影响整个系统x方向上的自旋） 将两个项结合就是总的哈密顿量： $$ H(t) = A(t) H_D + B(t) H_C $$ 边界条件： $$ A(0)=1,\\ B(0)=0 \\quad\\text{（完全量子）} \\ A(T)=0,\\ B(T) =1 \\quad \\text{(完全经典)} $$ 从初始哈密顿量： $$ H(0) = H_D $$ 一开始系统的状态为： $$ |\\psi(0)\\rangle = \\bigotimes_i \\frac{|0\\rangle_i + |1\\rangle_i}{\\sqrt{2}} $$ 也就是 所有自旋均匀叠加，完全无偏（这么选择的原因是：这个状态是 $\\sigma_x$的本征态，并且这个态可以通过演化到达其他所有的状态，因此就允许了系统在一开始能够对于整个状态空间的量子态进行搜索）。\n最终哈密顿量： $$ H(T) = H_C $$ 最终哈密顿量的基态即为优化问题的最优解（因为基态的能量最低，前面将优化问题的目标函数类比为Ising model的能量，那么最优解对应的态自然就是基态）。\n那么现在有1个问题：\n如何保证系统能够演化到最终的最优解的状态？\u0026mdash;-（量子绝热定理） Hopfield 神经网络 Ising model 是固定不同自旋之间的耦合强度 $J_{ij}$，通过改变温度，来观察这些自旋之间的集体行为（相变，相变温度 $T_c$）。那么基于Ising model 的Quantum Annealing 其实也是同理的。\n人大脑中的神经元与自旋类似。当人接收到外部信息时，这些神经元要么处于激活状态（+1），要么处于未激活状态（-1），并且神经元之间由突触连接，这个连接的强度变化由早期的Hebbian Theory决定：\n当对于某一个事件而言，若两个神经元之间同时处于激活状态，那么它们之间的连接强度增强。\n由此，Hopfield就联想到了物理中的Ising Model： $$ E=-\\frac{1}{2}\\sum_{i,j}J_{ij}\\sigma_i\\sigma_j $$ 这里不考虑外部影响，只考虑神经元之间的耦合，每个神经元都与其他所有的神经元有连接（这个连接时对称的，即A和B之间的耦合强度 $J_{AB} = J_{BA}$）。\n仅仅用Ising model来解释神经元之间的连接是不够的，还需要解释，一个神经网络是如何学习与回忆的。\n记忆： 在解释神经网络是如何学习与回忆之前，有一个重要的概念就是记忆。在Ising model 中基态是能量最低的态，量子退火算法也是通过找到基态，从而找到了最优解，那么神经网络中也有一个基态，这个基态对应着记忆。\n为什么记忆就是基态呢？\n可以这样理解，当你在处理某一类的问题时，就像将小球丢进一个记忆空间中（这个记忆空间其实是你学习过程中形成的），当你在回忆你的记忆时，其实就是小球滚动寻找下图中最低点的过程（寻找基态的过程）\n学习： 假设有N个神经元，正在学习某一个方面的内容，接收信息，更新N个神经元之间的连接强度 $W_{ij}$: $$ W_{ij}=\\frac{1}{N}\\sum_{\\mu=1}^P\\xi_i^\\mu\\xi_j^\\mu $$ 其中i,j 表示不同的神经元。\nTips:\nP表示接受的信息有P个patterns ，比如说你在学习如何识别图片中的内容，你接收到了三张图片（“A”，“B”，“笑脸”），此时就有3个Patterns的信息 $\\xi_j^\\mu$表示第j个神经元对于第 $\\mu$个pattern的反应，比如对于图片A，3号神经元是Active的，但是4号神经元却是睡觉。 重复学习会导致什么结果？ 回忆： 当你完成了对于某一个方面内容的学习，下一次你需要这方面内容的时候，你就需要去回忆\u0026ndash;找到这个记忆\u0026ndash;找到当前记忆空间中的最低谷。\n此时，神经元之间的强度固定（其实应该是减弱的，但是是整体减弱，所以忽略），但是此时你神经元的状态却是随机的，所以回忆的过程是：在记忆空间中，随机地释放小球，让小球寻找记忆的过程。\n举一个具体的例子就是，比如说图片识别，当一个神经网络学会了图像识别，当放一个模糊的照片给神经网络，让其进行识别，那么此时网络就会按照如下的规则来更新每个神经元的状态： $$ S_i\\leftarrow\\mathrm{sign}\\left(\\sum_jW_{ij}S_j\\right) $$ 这个规则要表达的意思其实是将第i个神经元周围所有神经元的状态及其突触连接强度综合起来，去更新其状态。sign函数是一个符号函数，内部结果大于0，则返回1，反之-1。\n问题： 重复学习在神经网络中的效果是什么？ 如果神经元之间的连接强度不对称会发生什么 展望与思考 量子退火算法使用Ising model，通过加入量子涨落，并缓慢地降温，使得系统一开始可以探索所有可能性的空间，最后让基态落在最优解上。\nHopfield 神经网络 通过Ising model 与神经元网络之间的类比，并结合神经科学中的Hebbian learning theory ，使得神经网络有了学习，回忆等功能。\n那么问题是：随着神经科学的不断进步，人类对于大脑的研究更加深入，Hebbian learning theory 可不可以替换成现在对于神经元研究最新的理论，使得这个神经网络更加强大呢？\n答案是：Predictive Coding\nPredictive Coding 传统的认知观点认为大脑像一个“照相机”：接收外界信号 -\u0026gt; 处理信号 -\u0026gt; 产生感知。 Predictive Coding（PC） 则认为大脑有两层-高层区域和底层区域，其中高层区域负责预测，底层区域负责接收真实的输入，比如当我们看到一个只有两个腿的动物，高层就会认为我们看到的是一个人，而底层告诉高层，看到的是一个袋鼠，那么这时候就产生了误差。：\n自顶向下（Top-Down）的预测： 大脑的高层区域（概念层）时刻在根据记忆和经验，向低层区域（感觉层）发送“预测”信号（它认为现在的世界是什么样的）。 自底向上（Bottom-Up）的误差： 感觉器官接收真实的输入。如果输入和预测不一致，就会产生**“预测误差”（Prediction Error）**。 误差传递与更新： 只有这个“误差”信号会向上传递，用来修正高层的模型。 因此PC认为大脑的核心目标是最小化高层区域的预测误差。其数学过程如下：\n我们将 Predictive Coding 看作一个分层高斯生成模型（Hierarchical Gaussian Generative Model）。为了简化，我们只看两层：\n观测层 (Level 0): $\\mathbf{x}$ (感觉输入) 隐层 (Level 1): $\\mathbf{r}$ (大脑内部的表征/状态) 1. 定义能量函数 (The Energy Function) 在物理学中，系统倾向于演化到能量最低的状态。在这里，我们定义一个目标函数 $F$（即变分自由能的简化形式，在统计学上等价于负对数似然），它衡量了“预测误差”的大小。\n假设高层 $\\mathbf{r}$ 通过权重矩阵 $W$ 线性预测低层，预测值为 $\\hat{\\mathbf{x}} = W\\mathbf{r}$。\n此时，预测误差 $\\mathbf{e}$ 为：\n$$\\mathbf{e} = \\mathbf{x} - W\\mathbf{r}$$\n为了同时满足“解释数据”和“先验约束（Prior）”，总能量 $F$ 通常被定义为：\n$$ F = \\underbrace{\\frac{1}{2} ||\\mathbf{x} - W\\mathbf{r}||^2}_{\\text{Sensory Prediction Error}}\n\\underbrace{\\frac{\\lambda}{2} ||\\mathbf{r} - \\mathbf{r}_{prior}||^2}_{\\text{Prior Prediction Error (Regularization)}} $$ 为简化讨论，我们暂时忽略先验项，只关注第一项（感觉误差）。 2. 两个过程：推断 (Inference) 与 学习 (Learning) Predictive Coding 的核心在于它将神经网络的运作分为了两个不同时间尺度的动力学过程：快过程（神经元活动）**和**慢过程（突触可塑性）。两者都是为了最小化 $F$。\nA. 快过程：神经元状态更新 (Inference) 当一张图片 $\\mathbf{x}$ 输入进来时，权重 $W$ 是固定的。网络需要调整神经元状态 $\\mathbf{r}$，使其生成的预测尽可能接近 $\\mathbf{x}$。这就是“感知”。\n我们在 $\\mathbf{r}$ 空间进行梯度下降：\n$$\\dot{\\mathbf{r}} = -\\frac{\\partial F}{\\partial \\mathbf{r}}$$\n计算梯度：\n$$\\frac{\\partial F}{\\partial \\mathbf{r}} = \\frac{\\partial}{\\partial \\mathbf{r}} \\left( \\frac{1}{2} (\\mathbf{x} - W\\mathbf{r})^T (\\mathbf{x} - W\\mathbf{r}) \\right) = -(\\mathbf{x} - W\\mathbf{r})^T W = -\\mathbf{e}^T W$$\n所以，神经元的动力学方程为：\n$$\\dot{\\mathbf{r}} = W^T \\mathbf{e}$$\n物理直觉： 这是一个局部计算。误差 $\\mathbf{e}$ 在底层计算出来，通过转置矩阵 $W^T$（反馈连接）传回高层，驱动 $\\mathbf{r}$ 改变，直到预测误差最小化（即 $\\dot{\\mathbf{r}} \\to 0$）。\nB. 慢过程：突触权重更新 (Learning) 这是你最关心的部分。当我们推断出较好的 $\\mathbf{r}$ 后（或者在推断的同时），我们需要更新突触权重 $W$，以便下次能更准地预测。\n我们在参数 $W$ 空间进行梯度下降：\n$$\\dot{W} = -\\mu \\frac{\\partial F}{\\partial W}$$\n其中 $\\mu$ 是学习率。计算梯度：\n$$\\frac{\\partial F}{\\partial W} = -(\\mathbf{x} - W\\mathbf{r}) \\mathbf{r}^T = -\\mathbf{e} \\mathbf{r}^T$$\n所以，权重的更新规则为：\n$$\\Delta W \\propto \\mathbf{e} \\cdot \\mathbf{r}^T$$\n或者写成张量形式（针对单个权重 $w_{ij}$）：\n$$\\Delta w_{ij} \\propto e_i \\cdot r_j$$\nPC与Hopfield 神经网络的区别： Hopfield 神经网络中的神经元是局部的，它只关心他和邻居有没有同时处于激活状态，但是不知道整体网络的目标是什么？（例如：这张图是不是猫？），所以当这个网络变深之后，就不知道哪个神经元应该为错误的输出负责，去纠正错误。\n现代深度学习使用反向传播解决了这个谁应该为错误负责的问题。具体是这样：比如当我们在做图像识别的时候，当我识别出的图片与目标图片存在偏差的时候，这时候计算出一个损失函数，这个损失函数通过反向传播可以看到谁对这个偏差的影响更大，此时通过调整对应的神经元即可修正这个偏差。但是问题是，大脑中并没有这种误差传导通路。\nPC 的巧妙之处： PC 引入了一种层级化的**“预测-纠错”机制**。你可以把它理解为每一层都有了自己的“质检员”（误差单元）。其中高层向下层发送预测，下层向上层反馈误差。 通过这种结构，PC 将原本遥不可及的“全局大目标”，转化为了每一层都能直接看到的“局部小目标”。神经元不再需要等待全局指令，只需要消除眼前的预测误差，就能自动引导整个网络走向最优解。\n参考文献 Ernst Ising (1925). Beitrag zur Theorie des Ferromagnetismus. Zeitschrift für Physik.\nKirkpatrick, S., Gelatt, C. D., \u0026amp; Vecchi, M. P. (1983). \u0026ldquo;Optimization by Simulated Annealing\u0026rdquo;. Science, 220(4598), 671-680.\nKadowaki, T., \u0026amp; Nishimori, H. (1998). \u0026ldquo;Quantum annealing in the transverse Ising model\u0026rdquo;. Physical Review E, 58(5), 5355.\nFarhi, E., et al. (2001). \u0026ldquo;A Quantum Adiabatic Evolution Algorithm Applied to Random Instances of an NP-Complete Problem\u0026rdquo;. Science, 292(5516), 472-475.\nHebb, D. O. (1949). The Organization of Behavior: A Neuropsychological Theory. Wiley.\nHopfield, J. J. (1982). \u0026ldquo;Neural networks and physical systems with emergent collective computational abilities\u0026rdquo;. Proceedings of the National Academy of Sciences (PNAS), 79(8), 2554-2558.\nAmit, D. J., Gutfreund, H., \u0026amp; Sompolinsky, H. (1985). \u0026ldquo;Spin-glass models of neural networks\u0026rdquo;. Physical Review A, 32(2), 1007.\nRao, R. P., \u0026amp; Ballard, D. H. (1999). \u0026ldquo;Predictive coding in the visual cortex: a functional.\nFriston, K. (2010). \u0026ldquo;The free-energy principle: a unified brain theory?\u0026rdquo;. Nature Reviews Neuroscience, 11(2), 127-138.\nWhittington, J. C., \u0026amp; Bogacz, R. (2017). \u0026ldquo;An approximation of the error backpropagation algorithm in a predictive coding network with local hebbian synaptic plasticity\u0026rdquo;. Neural Computation, 29(5), 1229-1262.\nMillidge, B., Tschantz, A., \u0026amp; Buckley, C. L. (2021). \u0026ldquo;Predictive Coding: A Theoretical and Experimental Review\u0026rdquo;. arXiv preprint arXiv:2107.12979.\n","date":"2025-11-25T17:40:16+08:00","permalink":"http://localhost:1313/2025/homeworkising-model-%E5%88%B0-predictive-coding-%E8%83%BD%E9%87%8F%E6%9C%80%E5%B0%8F%E5%8C%96%E7%9A%84%E8%87%AA%E7%84%B6%E6%BC%94%E8%BF%9B/","title":"Ising model 到 Predictive Coding-能量最小化的自然演进"},{"content":"","date":"2025-11-20T10:34:30Z","permalink":"http://localhost:1313/2025/test213ewddf/","title":"test|fdsdfds"},{"content":"","date":"2025-11-20T10:58:21+08:00","permalink":"http://localhost:1313/2025/test1/","title":"Test|1"},{"content":"三人行讲的是2033年的赵左右对于现在的生活并不满意，通过时间旅行技术想要回到过去（2008）改变自己的人生，他化名荀未来回到2008年遇到了过去（赵左右）与未来的自己（赵了），未来的自己想阻止他改变它的人生，因为另一种人生的他失去了他所爱之人。就这样两个人通过时空旅行改变了过去的自己，虽然最后赵左右成功带着他们的影响继续一个人生活，但是因为时间的影响，他逐渐发现无论自己如何试图改变，但始终战胜不了时间，不能够改变自己的人生。其实这种全知人生的无奈才是时间最痛苦的事，人生的快乐其实就是就是对于未来人生的未知，未知即未来。最后荀未来不忍心看到过去的自己这样挣扎的活着，他出手帮助过去的自己抹去了对于未来所知的一切，让时间回归正轨，但是这么多的努力真的无法改变什么吗？ 当然有！赵左右与徐图图之间的爱无法被时间改变！ 未来就是未知，但是爱或者感觉是永恒的，找到自己所爱的事，不后悔，不试图知晓未来或者改变过去，享受人生的未知，全知是如此的枯燥，探索体验才能在无数条可能的人生道路中走向那条属于自己的道路。\n","date":"2025-11-20T10:03:11+08:00","permalink":"http://localhost:1313/2025/%E8%A7%82%E5%90%8E%E6%84%9F%E4%B8%89%E4%BA%BA%E8%A1%8C/","title":"三人行"},{"content":"附录 参考文献 版权信息 本文原载于 quantum51.top，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-09-12T11:50:15+08:00","permalink":"http://localhost:1313/2025/notes%E7%94%B5%E5%8A%A8%E5%8A%9B%E5%AD%A6/","title":"Notes|电动力学"},{"content":"附录 参考文献 版权信息 本文原载于 quantum51.top，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-09-12T11:49:55+08:00","permalink":"http://localhost:1313/2025/notesai/","title":"Notes|AI"},{"content":"附录 参考文献 版权信息 本文原载于 quantum51.top，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-09-12T11:48:35+08:00","permalink":"http://localhost:1313/2025/processmaze_agent/","title":"Process|Maze_Agent"},{"content":"","date":"2025-09-12T11:48:35+08:00","permalink":"http://localhost:1313/2025/process%E5%A4%9A%E5%88%86%E9%87%8F%E8%B6%85%E5%AF%BC/","title":"Process|多分量超导"},{"content":"Plan：使用光子晶体进行计算并且与传统的光学计算进行比较 Details：\n1. Master the Theorem of the Photonic Crystal 1. Simulated the Crystal 1. Compare it 附录 参考文献 版权信息 本文原载于 quantum51.top，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-09-12T11:48:35+08:00","permalink":"http://localhost:1313/2025/process%E8%BF%9B%E7%A8%8B/","title":"Process|进程"},{"content":"量子纠缠的应用 可能很多人会想，量子纠缠这么神秘，众多科学家历经坎坷终于证明了量子纠缠存在的合理性。那么它有什么用呢？或者说，它能够解决哪些问题呢？\n对于量子纠缠，首先想到的是Alice和Bob双方共享的Bell态，只要有一方对于自己的系统进行测量，无论多远，都会影响另一方的测量结果，即纠缠的关联性。那么由此，我们可以联想到它与并行计算有同理之处，只不过，量子纠缠里的并行是双方互相影响的并行，而并行计算里是计算机对于一个大任务进行分解成许多小的，可以独立执行，或者合作完成的子任务，然后将这些子任务分配给多个处理器，让其同时进行计算。\n那么这一并行或者关联的特性，能够让量子纠缠碰撞出怎么样的火花呢？首先想到的就是针对大数分解的Shor算法，它可以有效的解决应用数学里最有趣的问题之一—将大数分解成多个素数，它可以用来破解常用的RSA加密方案。\nShor算法 一些前置知识 数论知识 素数 我们说一个数$a$是素数（prime number），是指它只有1和它本身作为因数（即$a$只能被1和它本身整除）。举一些例子，比如35，它的因子是：1，5，7，35，所以他不是素数，又比如71，它的因子是：1，71，所以它是素数。\n共素 如果我们说两个自然数$a和b$共素（互质），也就是说，他们的最大公因数为1（记为$\\gcd(a,b)=1$）。\n最大公因数（the greatest common divisor） 两个数$a和b$的最大公因数为$\\gcd{(a,b))}$，具体的计算过程如下：\n写出a的因子\n写出b的因子\n最后通过比较找到两者都有的最大因子。\n举个例子，比如计算24和88的最大公因数：\n1. 24的因子有：1，2，3，4，6，8，12，24 1. 88的因子有：1，2，4，8，11，22，44。 1. 所以他们的最大公因子是8。 模N 我们说一个整数的模N，即用这个数Q去除以N取余数的操作，那么自然而然这个可能的余数就会组成一个模N意义下的整数集合$\\Z_N$（即所有可能的余数）是： $$ \\Z_N = {0，1，2，\\dots，N-1} $$ 比如，$Q=6 ，N =5，那么Q \\pmod N = 6%5 = 1$\n模N的乘法群 模N群就是有所有与N共素的整数在模N意义下构成的乘法群，这个群记为$\\Z_N^{\\ast}$,群中的元素a满足条件： $$ a \\in Z ,1\\leq a \u0026lt;N , \\gcd{(a,N)} =1 $$ 该群的运算是模N下的乘法运算： $$ a\\cdot b \\pmod N $$ 该群的性质有：\n单位元1的存在性：$\\gcd{(1,N)}=1$，符合模N群的定义，即单位元1存在并且$a \\cdot 1 \\equiv a \\pmod N$。\n逆元的存在性：$\\forall a \\in \\Z_N^{\\ast} ,\\exist a^{-1}$ ,使得 ： $$ a \\cdot a^{-1} = 1 \\pmod{N} $$\n封闭性：如果$a，b \\in \\Z_N^*$，则有$\\gcd{(ab,N)} = 1$，即a，b的乘积也在模N群中\n阶为r，表示与N互质的整数的个数，即这个群的大小\n下图就是单位元上的六个单位根，可以将其看成模6群的几何结构（因为两者同构）\n抽屉原理 在数学上，抽屉原理是指当n个物品放入m个抽屉时，若n\u0026gt;m，则至少有一个抽屉里面有多个物品。比如一个数量足够大的人群中，一定有同一天出生的人，但是抽屉原理不会告诉你他们是谁？但是一定存在。\n时间复杂度 在计算机科学中，时间复杂度是一个函数，它定性的描述某一个算法的运行时间随着输入规模增长的速度。比如说一个算法的时间复杂度是$O(n)$，那么当该算法的输入变成两倍，那么运行时间也变成两倍。这么做的意义是：衡量算法的实际表现，因为在实际使用一个算法的时候，往往不会去考虑输入数据的规模，所以一个复杂度小的算法对于输入的数据的适应性就好。下面是常见的时间复杂度的排序（从上到下是由快到慢）：\n时间复杂度 名称 $O(1)$ 常数时间 $O(\\log n)$ 对数时间 $O(n)$ 线性时间 $O(n \\log n)$ 线性对数时间 $O(n^2)$ 二次时间（平方） $O(n^3)$ 三次时间（立方） $O(2^n)$ 指数时间 $O(n!)$ 阶乘时间 量子相位估计： 量子相位估计（Quantum Phase Estimation），和他的名字一样是估计相位，这个相位是算符U本征方程$U\\ket{\\psi} = e^{2\\pi i\\theta}\\ket{\\psi}$中的$\\theta$。具体流程如下：\n首先准备好一个初态$\\ket{\\Psi_0}=\\ket{0}^{\\otimes n}\\ket{\\psi}$，其中$\\ket{\\psi}=\\sum_{j=0}^{2^m-1}\\alpha_j\\ket{j}$是代表m个qubit的状态，其中j代表不同的长度为m的二进制串的值。\n然后对前面n个qubit做Handmard 门操作$H^{\\otimes n}\\otimes I_m$,得到态$\\ket{\\Psi_1}$,即： $$ \\ket{\\Psi_1} = (H^{\\otimes n}\\otimes I_m)(\\ket{\\Psi_0}) = \\frac{1}{2^{\\frac{n}{2}}}(\\ket{0}+\\ket{1})^{\\otimes n }\\ket{\\psi} \\\\ = \\frac{1}{2^{n/2}}\\sum_{j = 0}^{2^n-1}\\ket{j}\\ket{\\psi} $$\n对态$\\ket{\\Psi_1}$做受控U门操作，$U = \\sum_{k=0}^{2^n-1}\\ket{k}\\bra{k}\\otimes U^k$,由此得到态$\\ket{\\Psi_2}$: $$ \\ket{\\Psi_2} =\\sum_{k=0}^{2^n-1}\\ket{k}\\bra{k}\\otimes U^k(\\frac{1}{2^{n/2}}\\sum_{j = 0}^{2^n-1}\\ket{j}\\otimes\\ket{\\psi}) \\\\ = \\frac{1}{2^{n/2}}\\sum_{k=0}^{2^n-1}\\sum_{j=0}^{2^n-1}\\ket{k}\\delta_{jk}\\otimes e^{2\\pi ik\\theta}\\ket{\\psi} \\\\ =\\frac{1}{2^{n/2}}\\sum_{j=0}^{2^n-1}e^{2\\pi ij\\theta}\\ket{j}\\otimes \\ket{\\psi} \\\\ = \\ket{\\Phi_2} \\otimes\\ket{\\psi} $$ 所以这就由对于纠缠态$\\ket{j}\\ket{\\psi}$的操作，使得$\\ket{\\psi}$中信息（本征值中的相位），传递到了前一部分的叠加态的振幅当中。\n对态$\\ket{\\Psi_2}$中的$\\ket{\\Phi_2}$进行大小为N=$2^n$量子傅立叶逆变换（$QFT_{2^n}^{-1}$）,得到态$\\ket{\\Phi_3}$。量子傅立叶变换为(上式为变换，下式为逆变换)： $$ QFT_N \\ket{x} = N^{-1/2} \\sum_{k=0}^{N-1} e^{\\frac{2\\pi i}{N} kx} \\ket{k} \\\\ QFT_N^{-1} \\ket{k} = N^{-1/2} \\sum_{x=0}^{N-1} e^{-\\frac{2\\pi i}{N} kx} \\ket{x} $$ 那么对于态$\\ket{\\Phi_2}$进行$QFT_{2^n}^{-1}$，得到： $$ \\ket{\\Phi_3} = QFT_{2^n}^{-1} \\left( \\frac{1}{2^{n/2}} \\sum_{j=0}^{2^n - 1} e^{2\\pi i j \\theta} \\ket{j} \\right) \\\\ = \\frac{1}{2^{n/2}} \\sum_{j=0}^{2^n - 1} e^{2\\pi i j \\theta} \\left(\\frac{1}{2^{n/2}} \\sum_{x=0}^{2^n-1} e^{\\frac{-2\\pi ijx}{2^n}} \\ket{x} \\right) \\\\ = \\frac{1}{2^{n}} \\sum_{j=0}^{2^n -1} \\sum_{x=0}^{2^n -1} \\exp{\\left( 2\\pi ij (\\theta -\\frac{jx}{2^n})\\right)} \\ket{x} $$\n然后对上面的态在计算基${\\ket{x}}$测量，测得不同x的概率为：$|c_x|^2$,并且我们定义$2^n \\theta = a+2^n \\delta$，其中$a$是最接近$2^n\\theta$的整数，所以$2^n \\delta$要满足$0\\leq|2^n\\delta|\\leq 1/2$(因为，如果a是2.4，那么估计值就是2，误差为0.4,如果a = 2.7，那么估计值为3，误差为0.3，所以$2^n \\delta$不会超过0.5)。由于这个定义，$c_x$就变成了： $$ c_x = \\frac{1}{2^n}\\sum_{j=0}^{2^n-1} e^{\\frac{2\\pi ij}{2^n}(x-a)}e^{2\\pi i\\delta j} $$\n测量态$\\ket{\\Phi_3}$,我们可以从式8中发现，测量到$x = 2^n\\theta$的概率最高（因为此时处于干涉相加，所以系数最大），因此对于量子相位估计来说，想要估计的量$\\theta$被放在测量概率最大的态上。\n连分数算法 当我们有一个实数$\\alpha$，我们想要找到两个自然数$b和c$使得$\\frac{b}{c}=\\alpha$。\n具体流程是这样的：\n首先我们对$\\alpha$做连分数展开，得到一个整数序列$[a_0;a_1,a_2,\\dots,a_n]$，并满足： $$ \\alpha = a_0 + \\cfrac{1}{a_1 + \\cfrac{1}{a_2 + \\cfrac{1}{\\ddots + \\cfrac{1}{a_k}}}} $$\n具体获得这个序列的方法如下：\n$a_0 = \\lfloor x \\rfloor$（取整数部分）\n令 $x_1 = \\frac{1}{x - a_0}$\n$a_1 = \\lfloor x_1 \\rfloor$\n重复上面的abc，直到误差足够小或达到预定项数。\n然后生成收敛值序列${\\frac{p_0}{q_0},\\frac{p_1}{q_1},\\dots,\\frac{p_n}{q_n}}$,其中p_i,q_i的计算过程如下:\n初始化：$p_0 = a_0,q_0=1$;\n$p_1 =a_0a_1+1,q_1 = a_1$;\n对于$i \\geq 2$的情况： $$ p_i= a_ip_{i-1}+p_{i-2} \\\\ q_i = a_iq_{i-1}+q_{i-2} $$\n这个收敛值序列的值会越来越接近我们的实数$\\alpha$,所以最后我们可以选取符合我们要求的$p_i和q_i$作为我们的$b和c$。\n可以举一个例子，当我们有一个实数M = 0.833984375（约等于$\\frac{427}{512}$）,我们通过上面的算法可以先得到连分数序列[0;1,5,42,2]，然后计算得到收敛值序列：$[\\frac{0}{1},\\frac{1}{1},\\frac{5}{6},\\frac{211}{253},\\frac{427}{512}]$，我们可以看到最后一个收敛值就是我们要得到的分数。\n密码破解 对于平时用的加密方案RSA，其加密原理是：\n随机的选择两个大素数 $p和q$，其中 $p，q$分别代表公钥和私钥，你可以理解为，公钥是公开的，而私钥是你自己的 计算模数 $n = p\\times q$,这个模数 $n$是公钥和私钥的公共部分 计算欧拉函数 $\\phi(n) = (p-1)(q-1)$ 计算公钥指数e：在范围 $[1,\\phi(n)]$内选择公钥指数e，并且公钥指数e和欧拉函数 $\\phi(n)$ 互质(Coprime) 计算私钥指数d：让 $e \\times d \\equiv 1 \\pmod{\\phi(n)}$，即d是e关于模 $\\phi(n)$的乘法逆元。 最终生成了公钥$(e，n)$，私钥$(d，n)$ 如果在什么都不知道的前提下，想要直接以暴力的手段破解某一个加密文件，那么就需要分解大整数n为两个大素数p和q，而分解大数这一问题在经典下最快的算法（数域筛选法）的时间复杂度（近似）是： $$ \\exp(((\\frac{64}{9})^{1/3})+o(1))(\\log n)^{1/3}(\\log{\\log n})^{2/3}) $$ 虽然不是指数时间，但也比多项式时间慢很多，当解决n比较大（大约1024位）的密钥时，这个算法就不可用了。\nShor算法的逻辑： 前面说了，经典计算里面可以通过并行计算来加速任务的完成时间，那么分解大数的问题可不可以用并行计算来处理，答案是并行计算的加速效果是线性的，而shor算法具有指数级的加速效果，并且shor算法的时间复杂度是： $O((\\log{n})^3)$，所以经典中的并行计算对于任务的加速效果并不如shor算法。\n那么Shor算法的逻辑是什么呢？\n首先任务是：给出一个大数M，我们需要找到M的整数因子（两个大素数），这就排除了M是偶数的可能性（如果是偶数的话，2自然就是M的一个因子，并且2是比较小的素数，这就使得这个密钥不再安全），并且当M分解成一个素数和另一个非素数，我们可以逐步迭代使得M最终分解成多个素数的乘积（这里可以注释一下给一个例子）。\n要解决这个问题有两部分：\n简化（Reduction）：将分解问题转换为周期查找问题（Order- Finding，后面简记为OF） 解决OF问题：用量子相位估计算法来解决OF问题，其中又包含了估计相位，以及提取周期两步 简化 首先我们在区间 $[2,M)$ 随机选择一个整数$a$，然后我们去计算 $\\gcd{(a,M)}$ ($a和M的最大公约数$)，那么就会有两种情况：\n$\\gcd{(a,M)} \\neq 1$，即它们的最大公约数是G，那么M就可以分解成G和 $\\frac{M}{G}$（ $\\gcd{(a,M) = G}$ 表明G是M的因子，即M可以被G整除），这时候整个算法结束。\n$\\gcd{(a,M)} = 1$，那么此时 $a和M共素$，则 a在模M整数乘法群（群里的元素都是和M共素且属于模M群）里，记为 $a \\in \\Z_M^{*}$。（后面基本上讨论的都是这个情况）\n如果属于步骤1的第二种情况，那么通过乘法群的逆元的存在性，则a在模M整数乘法群中存在逆元 $a^{-1}$使得： $$ a \\times a^{-1} = 1 \\pmod{M} $$ 后面的 $1 \\pmod{M}$表示在模M群里面的单位元1。\n然后由我们选择的a来生成包含不同幂次a的序列： $$ X：{a^1,a^2,\\dots} $$\n这个序列的长度是无限的,因为我们可以对a不断做取幂处理，由于$a \\in \\Z_{M}^{\\ast}$，所以每一个幂次的$a$在 $\\Z_M^\\ast$中都有一个对应的元素，即： $$ \\forall k \\in \\N ,\\exist Z_{k} \\in \\Z_{M}^{\\ast}，Z_k = a^k \\pmod{M} $$ 而$Z_M^\\ast$里面包含的元素是有限的（仅包含0，1，2，$\\dots$，M-1）。因此我们有：\n无数多个幂次的a（可以看出无数多个小球）。\n每一个幂次的$a^k$都会对应着$\\Z^{\\ast}_M$中的某一个元素，而$\\Z_M^{\\ast}$里面的元素是有限的（可以看成不同的抽屉）。\n由于抽屉原理，当我们有足够多的小球，那么就一定存在$i,j \\in \\R\\and i \u0026lt;j$，使得： $$ a^i = a^j \\pmod{M} \\quad/a^j = a^i \\pmod{M} $$ 即两个小球对应于同一个抽屉。然后由于 $a^j和a^i$$在\\Z_M^\\ast$ 中存在逆元$a^{-j}和a^{-i}$，所以在等式两边乘$a^{-i}$： $$ a^j*a^{-i} = a^{j-i} = 1 \\pmod{M} $$ 记$r = j-i$,这个r就是a在模M群中的阶（order），它说明了序列X是周期性的。\n​\n因此对于$\\gcd{(a,M)} = 1$情况，我们就可以通过找到r来对M进行分解，具体的过程如下：\n找到r后，首先判断r是不是偶数，如果不是，那么就需要重新寻找r\n如果r为偶数，那么 : $$ a^r -1 =(a^{r/2}-1)(a^{r/2}+1) \\equiv 0 \\pmod{M} $$ 这就说明M可以整除$(a^{r/2}-1)(a^{r/2}+1)$。（可以注释一下为什么到这没有完成分解）\n解决OF问题 所以现在分解M的问题就转变为找a的序列周期r的问题。\n首先给定了目标分解数M，和一个任意选择的$a$，我们想要找到周期r满足： $$ a^r = 1\\pmod{M} $$ shor算法本质上就是通过量子相位估计（QPE），估计出一个结果（包含r的分数），然后用连分数算法将周期r提取出来。对于shor算法的QPE，它的算符U定义为：\n$$ U|k\\rangle = \\begin{cases} \\ket{a^k \\pmod{M}} \u0026amp; 0 \\le k \u0026lt; M \\\\ \\ket{k} \u0026amp; M \\le k \u0026lt; 2^n . \\end{cases} $$ 上面定义表达的意思是，当$k \\in \\Z_M^\\ast$，则计算得到相应$a^k$在$\\Z_M^\\ast$中对应的元素,如果不在，那么就返回$k$本身。因为我们知道序列X存在最小的周期r，所以当我作用r次U到同一个态$\\ket{k}$ ，那么这时候就会返回$\\ket{k}$，即$U^r\\ket{k} = \\ket{k}$，因此$U^r = I$。\n假设U的本征态为$\\ket{\\psi}$，其本征值为$\\omega$,则有： $$ U\\ket{\\psi} = \\omega\\ket{\\psi} \\\\ U^r\\ket{\\psi} = \\ket{\\psi}=\\omega^r \\ket{\\psi} $$ 所以有$\\omega^r =1$,所以$\\omega_r^k = e^{\\frac{i2\\pi k}{r}}$,这里的角标r说明U有r个特征向量${\\ket{\\psi_j}}$，每个的特征值为$\\omega^j_r$。（这里用几何解释就是：r次单位根，见下图）。\n可以发现${\\ket{a^0},\\ket{a^1},\\dots,\\ket{a^{r-1}}}$也构成算符U的一组基矢，我们可以用它们来表示${\\ket{\\psi_j}}$，关系是(这其实像离散的傅立叶变换)： $$ \\ket{\\psi_j} = r^{-1/2}\\sum_{k=0}^{r-1} w_{r}^{-kj}\\ket{a^k} $$ 这里其实也可以用U作用到$\\ket{\\psi_j}$来验证，然后对$\\ket{\\psi_j}$求和得到： $$ \\frac{1}{\\sqrt{r}}\\sum_{j=0}^{r-1}\\ket{\\psi_j} = \\frac{1}{r}\\sum_{j=0}^{r-1}\\sum_{k=0}^{r-1}\\omega_r^{jk}\\ket{a^k} \\\\ =\\ket{1} + \\frac{1}{r}\\sum_{k=0}^{r-1} ( \\sum_{j=0}^{r-1}\\omega_r^{jk}) \\ket{a^k} =\\ket{1} $$ 第一个等号是因为$\\omega_r^{jk}=\\omega_r^{-jk} = e^{2\\pi ijk/r}$,最后一个等号是因为： $$ \\sum_{j=0}^{r-1}e^{2\\pi jk/r} = \\frac{1-e^{2\\pi ik}}{1-e^{2\\pi ik/r}} = 0 $$ 可以参考等比数列求和公式。\n有了这个关系我们就可以通过制备态$\\ket{1}$，然后展开得到U的每一个本征态，即$\\ket{1} = \\frac{1}{\\sqrt{r}}\\sum_{j=0}^{r-1}\\ket{\\psi_j}$。\nShor算法寻找r的过程是：\n首先根据M来确定说需要的量子比特数n，要满足:$2^n\u0026gt;M$，所以$n =\\lceil \\log_2 M \\rceil$，例如，当M = 31时，n = 5（通常来说只需要满足$n =\\lceil \\log_2 M \\rceil$，但是可以证明2n个比特数可以以足够的精度来寻找周期r）。\n然后制备初态$\\ket{\\Phi_0} = \\ket{0}^{\\otimes{2n}}\\ket{1}$（左边是第一寄存器，右边是第二寄存器），我们知道可以通过展开得到： $$ \\ket{\\Phi_0} = \\ket{0}^{\\otimes{2n}}\\frac{1}{\\sqrt{r}}\\sum_{j=0}^{r-1}\\ket{\\psi_j} $$\n对第一寄存器做Hadamard操作$H^{\\otimes2n}\\otimes I_m$，得到态 $$ \\ket{\\Phi_1} = (H\\ket{0})^{\\otimes 2n}\\frac{1}{\\sqrt{r}}\\sum_{j=0}^{r-1}\\ket{\\psi_j} \\\\ = \\frac{1}{2^n} \\sum_{x=0}^{2^{2n}-1}\\ket{x}\\frac{1}{\\sqrt{r}}\\sum_{j=0}^{r-1}\\ket{\\psi_j} $$\n然后对整个系统做受控$U_c$操作，得到态$\\ket{\\Phi_2}$: $$ \\ket{\\Phi_2} = U_c(\\ket{\\Phi_1}) = (\\sum_{k = 0}^{2^{2n}-1}\\ket{k}\\bra{k}\\otimes U^k) \\ket{\\Phi_1} \\\\ =\\frac{1}{2^n} \\sum_{x=0}^{2^{2n}-1}\\sum_{k=0}^{2^{2n}-1}\\delta_{kx}\\ket{k}(\\frac{1}{\\sqrt{r}}\\sum_{j=0}^{r-1}U^{k}\\ket{\\psi_j}) \\\\ =\\frac{1}{2^n} \\sum_{x=0}^{2^{2n}-1}\\sum_{k=0}^{2^{2n}-1}\\delta_{kx}\\ket{k}(\\frac{1}{\\sqrt{r}}\\sum_{j=0}^{r-1}\\omega_j^k\\ket{\\psi_j}) \\\\ =\\frac{1}{2^n} \\frac{1}{\\sqrt{r}}\\sum_{x=0}^{2^{2n}-1}\\sum_{j=0}^{r-1}\\omega^x_j \\ket{x}\\ket{\\psi_j} = \\frac{1}{\\sqrt{r}}\\sum_{j=0}^{r-1}\\ket{\\phi_j}\\ket{\\psi_j} $$ 其中$\\ket{\\phi_j}=\\frac{1}{2^n}\\sum_{x=0}^{2^{2n}-1}e^{2\\pi ijx/r}\\ket{x}$，从上式可以看出，我们如果对上面的态进行测量，我们测量到每一个结果$\\ket{\\phi_j}$的概率都是一样的，都是$\\frac{1}{r}$，所以我们在做完测量之后不能够知道是哪个$j$。\n然后对第一个寄存器做逆量子傅立叶变换$QFT_{2^{2n}}^{-1}$，得到即： $$ QFT_{2^{2n}}^{-1}\\ket{\\phi_j}=\\frac{1}{2^{n}}\\sum_{x=0}^{2^{2n}-1}e^{\\frac{2\\pi ijx}{r}}\\frac{1}{2^{n}}\\sum_{k=0}^{2^{2n}-1}e^{\\frac{-2\\pi ikx}{2^{2n}}}\\ket{k} \\\\ =\\sum_{k=0}^{2^{2n}-1}\\frac{1}{2^{2n}}\\left( \\sum_{x=0}^{2^{2n}-1} \\exp\\left( 2\\pi ix\\left(\\frac{j}{r} - \\frac{k}{2^{2n}}\\right) \\right) \\right)\\ket{k} \\\\ =\\sum_{k=0}^{2^{2n}-1}c_k \\ket{k} $$ 我们可以看到对于这个态，如果我们以基${\\ket{k}}$测量，那么我们测量到$k=2^{2n}\\frac{j}{r}$结果的概率最大。\n这里可能有一个问题，这里只是测量到的概率最大，但是不一定就会测量到这个包含$r的k$。但是我们完全可以多做几次测量，来确保这个结果就是包含$r$的那个结果。\n在得到包含r的测量结果k之后，我们就可以对其除以$2^{2n}$，就可以得到一个实数$G=\\frac{j}{r}$，但是j我们无从得知，所以我们不能直接计算得到r。\n这时候就可以用上面的连分数算法来提取得到，但是需要注意的是，在取r实际上是取符合要求的分母$q_k$(在收敛值序列中)，并且这个分母不能大于要分解的目标$M$。\n最后，对于$\\gcd{(a,M)} = 1$情况，在找到估计的r后，我们就可以对M进行分解了，具体的分解过程如下：\n找到r后，首先判断r是不是偶数，如果不是，那么就需要重新寻找r\n如果r为偶数，那么 : $$ a^r -1 =(a^{r/2}-1)(a^{r/2}+1) \\equiv 0 \\pmod{M} $$ 这就说明M可以整除$(a^{r/2}-1)(a^{r/2}+1)$。（可以注释一下为什么到这没有完成分解）\n然后计算$\\gcd{(a^{r/2}-1,M)}和\\gcd{(a^{r/2}+1,M)}$，得出M得两个因子。\nConclusion(总结) 我们通过shor算法实现了对于大数的分解，其中量子纠缠的作用体现在受控U门操作那里，他仅用了一次操作就将本征态的信息（本征值中的r）转移到了第一寄存器的系数上，使得测量概率和需要估计的r有关。\n附录: 注意$\\Z_*$最好用$\\Z_{\\ast}${\\ast} 格式要紧凑，行内公式前后不要留空格。 参考文献 版权信息 本文原载于 quantum51.top，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-05-09T14:06:10+08:00","permalink":"http://localhost:1313/2025/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87chapter3/","title":"毕业论文｜chapter3"},{"content":"量子纠缠的验证 Bell不等式 要验证量子纠缠态的存在性，我们首先要证明隐变量理论的矛盾性，这样就证明了非局域性是量子力学的本质特征。前面EPR论文提出了量子力学的不完备性，而应该由额外的变量来补充的论据。这些变量试图去恢复理论中的局域性（一个系统上的测量结果不受过去与之相互作用且遥远系统的影响）和因果性。在之后的一段时间里，有许多试图去完善隐变量理论的工作，但是均已失败告终。\nBell通过将隐变量理论数学化并加入局域性假设，证明了其与量子力学的统计预测不相容（具有矛盾），即非局域性是量子力学的典型特征。\n斯特恩-格拉赫实验 （斯特恩-格拉赫实验可以展开说）\n考虑一对自旋为$\\frac{1}{2}$的粒子，整个系统处于自旋单态（总自旋为0），两个粒子自由地朝反方向运动。自旋单态的表达式为：\n$$ \\ket{\\psi} = \\frac{1}{\\sqrt{2}}(\\ket{\\uparrow \\downarrow} - \\ket{\\downarrow \\uparrow}) $$\n式中$\\ket{\\uparrow\\downarrow}$表示两粒子系统的状态，也可写成$\\ket{\\uparrow} \\otimes \\ket{\\downarrow}$（左边为粒子1的自旋状态），$\\ket{\\uparrow}$表示单个粒子自旋向上，$\\ket{\\downarrow}$表示自旋向下。\n定义粒子1和2的自旋算符$\\vec{\\sigma_1}$和$\\vec{\\sigma_2}$（Pauli算符形式，自旋算符与Pauli算符的关系为$\\vec{S} = \\frac{\\hbar}{2}\\vec{\\sigma}$）。通过斯特恩-格拉赫实验测量某个方向（例如$\\vec{a}$为粒子1的测量方向）的自旋分量。\n测量粒子1的$\\vec{\\sigma_1} \\cdot \\vec{a}$可能得到$+1$或$-1$。由于系统反对称性（可补充解释），此时测量粒子2的$\\vec{\\sigma_2} \\cdot \\vec{a}$结果必然与粒子1相反（$-1$或$+1$）。\n隐变量理论的数学化 Bell通过以下两个假设引出隐变量原理：\n局域性假设：若两粒子自旋的测量在空间分离的方向进行，则一个磁铁的方向（测量粒子1的方向）不会影响另一个磁铁的测量结果。 因果性假设：通过测量$\\sigma_1$的某个方向分量，可预测对应方向粒子2的自旋分量结果。 假设1指定了隐变量理论的局域性；假设2说明测量结果可被提前预测，对应隐变量$\\lambda$的存在性（$\\lambda$可以是单变量、一组变量或函数）。测量结果满足：\n$$ A(\\vec{a}, \\lambda) = \\pm 1, \\quad B(\\vec{b}, \\lambda) = \\pm 1 $$\n隐变量理论的期望值为：\n$$ P(\\vec{a}, \\vec{b}) = \\int d\\lambda , \\rho(\\lambda) A(\\vec{a}, \\lambda) B(\\vec{b}, \\lambda) $$\n而量子力学对自旋单态的期望值为：\n$$ \\langle \\vec{\\sigma}_1 \\cdot \\vec{a} ; \\vec{\\sigma}_2 \\cdot \\vec{b} \\rangle = -\\vec{a} \\cdot \\vec{b} $$\n主要证明 Bell不等式的推导步骤如下：\n归一化条件：$\\int d\\lambda , \\rho(\\lambda) = 1$ 测量结果限制：$A(\\vec{a}, \\lambda), B(\\vec{b}, \\lambda) = \\pm 1$ 引入新方向$\\vec{c}$，计算差值： $$ P(\\vec{a}, \\vec{b}) - P(\\vec{a}, \\vec{c}) = \\int d\\lambda , \\rho(\\lambda) A(\\vec{a}, \\lambda) A(\\vec{b}, \\lambda) \\left[ A(\\vec{b}, \\lambda) A(\\vec{c}, \\lambda) - 1 \\right] $$\n取绝对值并利用积分性质，最终得到Bell不等式： $$ |P(\\vec{a}, \\vec{b}) - P(\\vec{a}, \\vec{c})| \\leq 1 + P(\\vec{b}, \\vec{c}) $$\n验证实例 取$\\vec{a} = (0,0,1)$, $\\vec{b} = (1,0,0)$, $\\vec{c} = (1/\\sqrt{2}, 0, 1/\\sqrt{2})$：\n$P(\\vec{a}, \\vec{b}) = 0$ $P(\\vec{a}, \\vec{c}) = -1/\\sqrt{2}$ $|P(\\vec{a}, \\vec{b}) - P(\\vec{a}, \\vec{c})| = 1/\\sqrt{2} \\approx 0.707$ $1 + P(\\vec{b}, \\vec{c}) = 1 - 1/\\sqrt{2} \\approx 0.293$ 显然$0.707 \u0026gt; 0.293$，违反Bell不等式，说明隐变量理论无法解释量子力学预测。 $$ f(g(x)) = \\begin{cases} 0, \u0026amp; g(x) \u0026lt; 2 \\\\ 1, \u0026amp; g(x) \\geq 2 \\end{cases} $$\n结论 通过证明Bell不等式在量子力学中不成立，表明非局域性是量子力学的本质特征，从而验证了量子纠缠的合理性。\nCHSH游戏： 上面描述了两种可行的实验方案，但是其实还有一种更容易理解的思想实验（CHSH游戏），通过这个游戏的分析表明任何经典的局部隐变量理论都不能够解释量子纠缠的情况。由于该游戏确实在物理上可实现，因此就证明了经典物理从根本上无法解释某些量子现象，至少在“局部”层面上无法解释。\nCHSH游戏的定义: 游戏有三个人,一个Alice,一个Bob,一个裁判:\n首先,裁判以均匀的概率随机地选定两个数 $x，y\\in {0,1}$ 然后，裁判把 $x$给Alice，$y$给Bob 最后，Alice$需要给出回应a \\in {0,1}$,Bob也需要给出回应$b\\in{0,1}$ 如果$x = y = 1$，则只有当Alice和Bob要给出不一样的回应才可以获胜；对于其他的情况，则需要Alice和Bob的回应一样才能获胜。\n经典情况： 在经典情况下，如果我们去找一个对于这个游戏的最优策略，那么只需要找到胜率最高的那种策略，根据下面的分析：\n$x$ $y$ 最佳的 0 0 $a和b相同$ 0 1 $a和b相同$ 1 0 $a和b相同$ 1 1 $a和b不同$ 我们可以从上面的表格看到，有三种情况都需要Alice和Bob选择一样的回应，所以对于经典的最优解就是：Alice和Bob两者的回应保持相同，则获胜的概率最大为 $\\frac{3}{4}$（对于这种策略，四种情况只有一种情况输）。\n量子情况： 对于量子情况，首先介绍一些对于量子比特和量子态的基础知识。\n基态： 让$s_1\\dots s_n \\in {0,1}^n$是一个长度为n的二进制串，$i\\in {0,1,\\dots,2^{n}-1}$是对应二进制串的值，比如n=2，那么此时二进制串为$s_1s_2={00,01,10,11}$,对应这四个二进制串的值为0,1,2,3。然后根据这个我们可以定义 $\\ket{s_1\\dots s_n}$是一个长度为 $2^n$的向量，假设这个向量里面的二进制串所对应的值为 $i$，则这个向量的第 $i+1$个位置为1，其余的位置为0，这个向量$\\ket{s_1\\dots s_n}$我们就称之为n个量子比特的基态。对于n=2(两个量子比特)的情况，那么就有 $\\ket{00},\\ket{01},\\ket{10,\\ket{11}}$这些基态，这些基态分别对应(下面的基态都是列向量）： $$ \\ket{00}=[1,0,0,0]^T，\\ket{01}=[0,1,0,0]^T \\\\ \\ket{10}=[0,0,1,0]^T，\\ket{11}=[0,0,0,1]^T $$\n量子态： 定义：n个量子比特的量子态是一个向量 $\\vec{x}$: $$ \\vec{x} = x_{0\\dots0}\\ket{0\\dots0}+ \\dots + x_{1\\dots1}\\ket{1\\dots1} \\\\ = \\sum_{S\\in{0,1}^n}x_s\\ket{S} $$ 上式中 $S$是遍历所有长度是n的二进制串，并且 $\\vec{x}$满足归一化条件： $$ |x_{0\\ldots0}|^2 + \\cdots + |x_{1\\ldots1}|^2 = 1. $$\n系数 $x_{0\\dots0},\\dots,x_{1\\dots1}$可以是复数，但是我们只考虑它们是实数的情况。\n量子门： 就像函数 $f(x)$一样，有输出对应着输入，这个函数相当于对这个输入做了某种操作；那么对应某个系统的量子态，我们应该如何去操作它改变它呢？上面我们提到了量子态是一个向量 $\\vec{x}$,那么量子门操作就是 $f(\\vec{x})$,并且要遵循如下的性质：\n归一化：对于所有满足归一化条件的 $\\vec{x}$，在经过量子门操作之后的量子态 $\\vec{y}=f(\\vec{x})$也要满足归一化关系。\n线性操作（可以在附录说一下为什么线性是必要的）：对于所有的可能的输入的向量 $\\vec{a}，\\vec{b}$以及所有实数 $c$，我们有 $f(\\vec{a}+\\vec{b})=f(\\vec{a})+f({\\vec{b}})$和 $f(c\\vec{a})=cf(\\vec{a})$.\n对于满足上面两个性质的量子门操作，我们称之为线性量子门。\n量子系统，孤立系统： 对于要如何去实现这样的二进制的量子态我们可以直接想到的是电子，我们可以依靠电子的自旋量子数是1/2的特性（这个特性使得电子再任意方向上的自旋都有两个本征态，自旋向上，自旋向下）去实现基态是 $\\ket{0},\\ket{1}$的量子系统。顺着这个思路，我们可以得出量子系统其实就是多个有顺序的电子的集合表示为 $E =(e_1,\\dots,e_n)$。\n因为每个电子要么自旋向上（0）要么自旋向上（1），所以这个量子系统的状态一定是二进制串 $S = s_1\\dots s_n\\in{0,1}^n$中的一个，那么我们可以将测量这个量子系统中每一个电子的自旋的过程描述为 $E \\to S$\n在大部分情况下，我们只关心庞大世界中的某一个系统，那么此时这个孤立系统是怎么样的，和复合系统的区别是什么？一个孤立的量子系统 $E$之所以孤立是因为他的测量事件和其他量子系统的测量是独立的，即：\n这个孤立系统的测量事件：$E \\to S$与所有其他的系统的测量 $E’ \\to S\u0026rsquo;$是独立的，也就是这个系统的测量结果并不会影响其他系统的结果。\n上面我们提到了测量事件和测量结果，那么对于一个处于某一个量子态的量子系统E，这些是如何定义的呢？\n测量公理： 假设 $E$是一个由n个电子 $(e_1,\\dots,e_n)$ 组成的孤立量子系统，根据前面的定义，我们可以用一个向量 $\\vec{x}$来表示这个系统的状态，如果我们去测量这个系统的状态，可能的结果是所有二进制串（长度为n） $S\\in{0,1}^n$中的一个，或者说这个系统的状态是不同基态的组合： $$ \\ket{\\psi} = \\sum_{S\\in{0,1}^n}x_s\\ket{S} $$ 那么此时我们知道当我们观测这个系统的时候，这个系统一定会处于基态中的一个，但是在观测前我们也许可以知道我们测量得到不同基态的概率 $|x_s|^2$,测量公理定义了这样的概率是： $$ Pr [E \\to S] =|x_s|^2 $$ 以及将我们可能对这个处于 $\\vec{x}$ 孤立系统E做出的物理操作定义为一个量子门 $f$，这样就使得前面有关与量子门的操作和定义能够在实际物理世界中存在对应。\n总而言之，这个公理将一个孤立的系统描述为某一个量子态，以及每一个物理上的操作（Physical process）描述为某一个量子门。\n张量积（Tensor Product）： 回想一下我们CHSH游戏中指定了Alice和Bob共享一个EPR对 $\\ket{\\psi}=\\frac{1}{\\sqrt{2}}(\\ket{00}+\\ket{11})$,那么这个状态其实是Alice的电子和Bob的电子相组合成的系统（但是这个两个系统之间有纠缠）。前面我们知道对于一个系统的状态可以用一个向量 $\\vec{x}=(x_1,\\dots,x_n)^T$（长度为n）来描述，如果此时还有另一个系统状态是 $\\vec{y}=(y_1,\\dots,y_m)^T$（长度为m），那么两个系统组合起来的状态由向量 $\\vec{\\Phi}$ 表示，那么这个向量应该如何定义呢？\n向量的张量积： 我们这里引入向量之间的张量积，定义为： $$ \\vec{\\Phi} = \\vec{x}\\otimes\\vec{y} $$ 并且这个向量 $\\vec{\\Phi}$的长度是nm，并且 $\\otimes$被称之为张量积。向量$\\vec{x}$和向量$\\vec{y}$之间的张量积定义为： $$ \\vec{x}\\otimes\\vec{y} = (a_1b_1,a_1b_2,\\dots,a_nb_{n-1},a_nb_n $$ 比如，但两个系统（$E_1，E_2$）的状态分别为 $\\vec{a}=(a_1,a_2)$和 $\\vec{b}=(b_1,b_2,b_3)$，那么这两个系统组合的状态 $\\vec{\\psi}$为： $$ \\vec{\\psi}=\\vec{a}\\otimes \\vec{b}=[a_1(b_1,b_2,b_3),a_2(b_1,b_2,b_3)] \\\\ =(a_1b_1,a_1b_2,a_1b_3,a_2b_1,a_2b_2,a_2b_3) $$\n不同孤立系统状态的张量积： 上面对于两个系统组合起来的张量积表示有一个前提条件就是，它们两个都是孤立系统，即它们不能有相互作用或者纠缠（如EPR态）。它表述为一个定理：\n如果两个系统 $E_1$和 $E_2$都是孤立的系统，并且两个分别由向量 $\\vec{x}$和$\\vec{y}$表示，则它们的联合系统状态 $E_1E_2$ 用向量 $\\vec{x}\\otimes\\vec{y}$表示\n作用在两个系统的量子门的张量积： 我们已经定义了两个孤立系统的联合状态是怎么样的，那么我们想，如果我们想对系统（A和B）进行物理操作（相当于作用量子门）,那么这些操作是如何影响整个系统的联合状态的呢？我们可以定义：\n让 $f：V^n\\to V^n$表示对于系统A的一个线性操作（线性的量子门），$g:V^m\\to V^m$表示对于系统B的一个线性操作，则对于这整个系统的联合状态 $\\vec{a}\\otimes\\vec{b}$而言，我们对于整个系统的操作 $f\\otimes g$作用效果为： $$ (f\\otimes g)(\\vec{a}\\otimes\\vec{b}) = f(\\vec{a})\\otimes g(\\vec{b}) $$ 这里对于整个系统AB的操作 $f\\otimes g$ 可以由一个公理指定（$f$作用与A系统，$g$作用于B系统）。（此处可以说明一下这里如果两个操作并不同时发生，这个定义还是有效的吗？，因为两个系统是孤立系统，所以互不影响。）\nCHSH游戏的一种解法： 在CHSH游戏中，我们让Alice和Bob共享一个Bell态 $\\frac{1}{\\sqrt{2}}(\\ket{00}+\\ket{11})$，将第一个电子分配给Alice（左边的比特），将第二个电子分配给Bob（右边的比特），那么此时Alice和Bob都可以测量各自电子的自旋，并且得到的结果要么是+1要么是-1，最后将测量的结果回应给裁判（但是这里的结果是+1，-1，我们之后会处理将这个测量结果和0，1对应起来）但是此时两者是严格正相关的，也就是当Alice测量的+1的时候，整个系统的状态就塌缩到 $\\ket{00}$，那么这时候Bob测量的结果就一定是+1，另一种情况也是一样。\n这种情况下恰好就对应了经典情况下的最优策略（始终保持Alice和Bob的回应相同），这也就说明了为什么在量子情况要用Bell态，因为在Alice和Bob不对Bell态做出任何操作的情况下，就已经处于经典情况胜率的上界（75%）了。\n所以如果要找到比经典情况最优策略胜率更高的策略，那么Alice和Bob就必须对这个Bell态进行物理操作了。\n旋转门的引入： 因为我们知道，Alice和Bob都是将各自电子自旋的测量结果（进行处理），最后返回给裁判是0和1，但是其实对于电子的自旋测量可以改变方向，那么就需要引入一个量子门操作 $R_{\\theta}$，它的几何意义其实就是将二维空间中的某一个向量顺时针旋转 $\\theta$角度，由此可以得到他的数学定义是1：\n$$ \\begin{aligned} R_{\\theta}(a_1\\ket{0}+a_2\\ket{1}) \u0026amp;= (a_1\\cos{\\theta}-a_2\\sin{\\theta})\\ket{0} \\ \u0026amp;\\quad + (a_1\\sin{\\theta}+a_2\\cos{\\theta})\\ket{1} \\end{aligned} $$\n有了旋转门之后，Alice和Bob就可以分别对于各自的电子进行旋转，之后再执行测量操作，我们可以将Alice和Bob的操作记为 $R_{A_{0,1}}\\otimes R_{B_{0,1}}$，这里的角标对应着，当Alice或者Bob收到x或者y为0和1的情况。\n胜率的定义： 我们这里将Alice和Bob的总胜率定义为 $w$。在CHSH游戏中，Alice和Bob分别收到来自裁判的x,y，Alice和Bob分别给出回应a，b。对于每一对可能的$(x,y)$，他们获胜的条件可以简化为： $$ a \\oplus b = x \\cdot y $$ 前面是逻辑上的异或操作（简而言之就是相同为0，不同为1），后面是普通的乘法操作（只有当 $x=y=1$时，右边才等于1）2\n假设对于每一种 $(x,y)$的胜率记作 $Pr[win|(x,y)]$，由于每种 $(x,y)$出现的概率相同都是1/4，所以总的胜率 $w$为： $$ w=\\frac{1}{4}\\sum_{(x,y)}Pr[win|(x,y)] $$\n测量结果的处理： 我们知道Alice和Bob对于任意方向电子自旋的测量结果是+1/-1，但是游戏规则中需要Alice和Bob做出回应0/1，那么我们就需要做出如下的处理： $$ a = \\frac{1 - a^\\ast}{2}, \\quad b = \\frac{1 - b^\\ast}{2} $$ 这里的 Alice和Bob的测量结果$a^\\ast=\\pm1,b^\\ast=\\pm1$，而 $a$和$b$就是Alice和Bob对于测量结果处理之后给裁判各自的回应，回应0就对应着测量结果1，回应1就对应测量结果是-1。\n因此上面对于a,b的获胜条件，转化为测量结果$ a^\\ast $和 $ b^\\ast $的获胜条件为：\n$$ \\begin{aligned} a \\oplus b \u0026amp;= x \\cdot y \\ \\left(\\frac{1-a^\\ast}{2}\\right)\\oplus\\left(\\frac{1-b^\\ast }{2}\\right) \u0026amp;= x \\cdot y \\end{aligned} $$\n代入之后第二个式子可以用一个公式化简： $$ u \\oplus v = u+v-2uv $$ 上面的 $u和v$都代表的是二进制数。所以得到： $$ \\begin{aligned} \\frac{1-a^\\ast b^\\ast}{2} \u0026amp;= x \\cdot y \\\\ a^\\ast b^\\ast \u0026amp;= 1-2xy \\end{aligned} $$\n我们可以用一个表格看到$1-2xy$其实可以等价为$(-1)^{xy}$：\n$x$ $y$ $xy$ $1-2xy$ $(-1)^{xy}$ 0 0 0 1 1 0 1 0 1 1 1 0 0 1 1 1 1 1 -1 -1 由此可以得到获胜条件变成Alice和Bob的测量结果要满足： $$ a^\\ast b^\\ast =(-1)^{xy} $$\n用测量结果的乘积表示赢的概率： 记任意一次测量 $(a^\\ast,b^\\ast)$的概率分布为${P_{++},P_{+-},P_{-+},P_{\u0026ndash;}}$为对应结果的概率，角标的左边表示Alice的测量结果，右边表示Bob的测量结果，正负号代表测量结果为1和-1。所以双方测量结果乘积的期望是： $$ E[a^\\ast b^\\ast]=(+1)P_{++}+(-1)P_{+-}+(-1)P_{-+}+(1)P_{\u0026ndash;} $$\n因为赢得条件是$a^\\ast b^\\ast =(-1)^{xy}$，所以对于每一种情况的$(x,y)$而言，获胜的概率$Pr[win|(x,y)]$就等价于 $Pr[a^\\ast b^\\ast=(-1)^{xy}]$。\n对于任意一次测量$(a^\\ast,b^\\ast)$的概率分布${P_{++},P_{+-},P_{-+},P_{\u0026ndash;}}$，有： $$ Pr[a^\\ast b^\\ast=(-1)^{xy}] = \\sum_{a^\\ast b^\\ast=(-1)^{xy}}Pr[a^\\ast,b^\\ast] $$ 式中$Pr[a^\\ast,b^\\ast]$代表两者测量的概率分布（离散的），所以对于等式的右侧，我们可以分两种情况： $$ \\sum_{a^\\ast b^\\ast=(-1)^{xy}} \\mathrm{Pr}[a^\\ast,b^\\ast] = \\begin{cases} P_{++}+P_{\u0026ndash;}, \u0026amp; (-1)^{xy}=+1 \\ P_{+-}+P_{-+}, \u0026amp; (-1)^{xy}=-1 \\end{cases} $$\n可以看到： $$ \\begin{aligned} P_{++}+P_{\u0026ndash;} \u0026amp;= \\frac{1}{2}\\left[1+(P_{++}+P_{\u0026ndash;}-P_{+-}-P_{-+})\\right] \\ \u0026amp;= \\frac{1}{2}(1+E[a^\\ast b^\\ast]) \\end{aligned} $$ 第二个等号是由归一化 $P_{++}+P_{+-}+P_{-+}+P_{\u0026ndash;}=1$。同样的，对于$P_{-+}+P_{+-}$有： $$ P_{-+}+P_{-+}=\\frac{1}{2}(1-E[a^\\ast b^\\ast]) $$\n所以可以得到： $$ Pr[win|x,y]=\\frac{1+(-1)^{xy}E[a^\\ast b^\\ast]}{2} $$\n在Alice和Bob收到$(x,y)$后，他们对应的做出对于各自电子自旋测量方向的旋转操作$A_x$和$B_y$，对于他们共享的Bell态$\\ket{\\psi}$而言就是量子门操作$A_x \\otimes B_y$，那么他们测量结果的乘积的期望$E[a^\\ast b^\\ast]$就是： $$ E[a^\\ast b^\\ast] = \\bra{\\psi}A_x \\otimes B_y\\ket{\\psi} $$\n然后将这个期望值代入式23，再将式23代入总的获胜概率$w$的定义，得到： $$ \\begin{aligned} \\omega\u0026amp;=\\frac{1}{4}\\sum_{x,y}\\frac{1+(-1)^{xy},\\langle\\psi|A_x\\otimes B_y|\\psi\\rangle}{2} \\ \u0026amp;=\\frac{1}{2}+\\frac{1}{8}\\sum_{x,y}(-1)^{xy},\\langle\\psi|A_x\\otimes B_y|\\psi\\rangle. \\end{aligned} $$\n我们可以定义总获胜概率为$w$和失败概率为$L$，以及两者之间的差值为$D=w-L$3，然后 $$ D = w-(1-w) = 2w-1 $$\n所以要得到总的获胜概率的上界等价于找到D的上界，由上可以得到： $$ \\begin{aligned} D\u0026amp;=2\\omega-1=2\\left[\\frac{1}{2}+\\frac{1}{8}\\sum_{x,y}(-1)^{xy}\\langle\\psi|A_x\\otimes B_y|\\psi\\rangle\\right]-1 \\ \u0026amp;=\\frac{1}{4}\\sum_{x,y\\in{0,1}}(-1)^{xy},\\langle\\psi|A_x\\otimes B_y|\\psi\\rangle. \\end{aligned} $$\n那么现在应该如何找到这个D的上界呢？\n如果根据量子力学的期望的定义，D可以写成： $$ D=\\frac{1}{4}\\left(\\langle A_0B_0\\rangle+\\langle A_0B_1\\rangle+\\langle A_1B_0\\rangle-\\langle A_1B_1\\rangle\\right) $$ 其中，$\\langle A_0B_0\\rangle$表示在量子态 $\\ket{\\psi}$下算符 $A_0 \\otimes B_0$的期望值，其余同理。\n然后定义四个投影算符 $P,P\u0026rsquo;,Q,Q\u0026rsquo;$，我们可以看成是一个投影操作，那么这个算符的本征值只有两个0和14，我们作用到Alice和Bob各自电子上的算符仅仅改变了电子的自旋方向，但是所得到的测量值还是+1和-1，所以可以做出如下的变换： $$ \\begin{aligned} A_0 \u0026amp;= 2P-1 \\ B_0 \u0026amp;= 2Q\u0026rsquo;-1 \\ A_1 \u0026amp;= 2Q-1 \\ B_1 \u0026amp;= 2P\u0026rsquo;-1 \\end{aligned} $$ 做出这个变换的理由是：我们对于电子的旋转的操作总可以等效成将电子的自旋向某个方向投影，并且保持了测量值的不变性。\n然后定义R： $$ R =\\langle A_0B_0\\rangle+\\langle A_0B_1\\rangle+\\langle A_1B_0\\rangle-\\langle A_1B_1\\rangle $$\n令$C =A_0B_0+A_0B_1+A_1B_0-A_1B_1$ 可以得到： $$ R =\\langle C\\rangle $$ 其中： $$ C = A_0(B_1+B_0)+A_1(B_0-B_1) $$\n然后我们计算$C^2$，因为$A_0，A_1，B_0，B_1$的本征值都是 $\\pm 1$，所以有： $$ A_0^2=A_1^2=B_0^2=B_1^2=1 $$ 5\n由此可以推出： $$ C^2 = 4+[A_0,A_1][B_1,B_0] $$ 其中$[A,B]$表示算符的对易子$AB-BA$，从这个等式可以看出，在经典情况下，Alice和Bob并不做出任何操作，所以等式右侧的第二项就是0，但是这一项正表现出了量子的非定域性特点。\n然后我们将变换关系29，代入计算得到： $$ C^2 =4+16[P,Q][P\u0026rsquo;,Q\u0026rsquo;] $$\n由于P，Q都是投影算符，所以有： $$ P^2 = P ,\\quad Q^2=Q ,\\quad P^{\\dagger} =P,\\quad Q^{\\dagger} = Q $$\n因为$A_0 = 2P-1$，所以： $$ \\begin{aligned} A_0^2 \u0026amp;= (2P-1)(2P-1) \\ \u0026amp;=4P^2-4P+I \\ \u0026amp;=4P^2-4P^2+I \\ \u0026amp;=I \\end{aligned} $$ 所以$|A_0|=1$，同理$A_1^2 = I$，$|A_1|=1$。\n我们想得到$[P,Q]$的范围，有$|A_0|，|A_1|=1$，以及： $$ \\begin{aligned} [A_0,A_1] \u0026amp;= (2P-I)(2Q-I)-(2Q-I)(2P-I) \\ \u0026amp;=4(PQ-QP) \\ \u0026amp;=4[P,Q] \\end{aligned} $$\n所以我们有$[P,Q] = \\frac{1}{4}[A_0,A_1]$。所以现在的想法是找一下$[A_0.A_1]$的范围。\n考虑$[A_0,A_1]$的范数（大小），再根据三角不等式，可以得到： $$ \\begin{aligned} |[A_0,A_1]|\u0026amp;=|A_0A_1-A_1A_0| \\ \u0026amp;\\leq |A_0A_1|+|A_1A_0| \\ \u0026amp;\\leq 2|A_0||A_1|=2 \\end{aligned} $$\n然后根据$[P,Q] = \\frac{1}{4}[A_0,A_1]$，得到： $$ |[P.Q]| \\leq \\frac{1}{2} $$\n对于$[P\u0026rsquo;,Q\u0026rsquo;]$的范数也同理小于等于二分之一，所以对于式（35）而言有范数形式： $$ |C^2| = 4+16|[P,Q][P\u0026rsquo;,Q\u0026rsquo;]| $$\n又因为$|[P.Q][P\u0026rsquo;,Q\u0026rsquo;]|\\leq |[P,Q]||[P\u0026rsquo;,Q\u0026rsquo;]|$(三角不等式)，所以： $$ \\begin{aligned} |C^2| \u0026amp;\\leq 4+16|[P,Q]||[P\u0026rsquo;,Q\u0026rsquo;]| \\ \u0026amp;\\leq 4+16\\times\\frac{1}{4} \\leq 8 \\end{aligned} $$ 第二个不等式代入了$|[P,Q]| \\leq \\frac{1}{2}$和$|[P\u0026rsquo;,Q\u0026rsquo;]| \\leq \\frac{1}{2}$。所以得到了$|C| \\leq 2\\sqrt{2}$ 这一结论。\n因为$R = \\langle C\\rangle$，所以对于R的绝对值有： $$ |R| = |\\bra{\\psi}C\\ket{\\psi}| \\leq |\\psi||C\\psi| = |C\\psi| $$ 上式中不等号是由于施瓦茨不等式$|uv|\\leq |u||v|$，最后的等号是因为$\\ket{\\psi}$是单位向量（所以它的模是1）。\n然后通过算符范数的定义：$|C|$是拉伸向量的最大的因子6。由这个定义我们可以得到： $$ |C| = \\sup_{|\\psi|=1}{|C\\psi|} $$ 其中$\\sup$是对于所有满足要求的$\\psi$找到目标函数的上界。于是对于式（19）有： $$ |R| \\leq |C\\psi| \\leq \\sup_{|\\psi|=1}{|C\\psi|}=|C| $$\n所以对于$|R|^2$有： $$ |R|^2 \\leq |C|^2 = |C^2| \\leq 8 $$ 7\n所以，对于R来说，有$|R| \\leq 2\\sqrt{2}$。然后根据定义$D = \\frac{1}{4}R$，得到总胜率和总败率之间的偏差D的上界是$\\frac{\\sqrt{2}}{2}$，即： $$ D = \\frac{1}{4}R \\leq \\frac{\\sqrt{2}}{2} $$\n最后我们通过$D = 2w-1$，得到量子情况下，总胜率$w$的上界为： $$ w = \\frac{D+1}{2} \\leq \\frac{\\sqrt{2}}{4}+\\frac{1}{2} \\approx 85% $$\n所以可以通过CHSH游戏8表明，通过两个距离很远（足以排除以光速进行信息传递）的双方，各自可以访问（可以测量并且操作）一个量子纠缠态的一半，通过合适的测量操作，可以给出比经典最优策略更优的量子策略。因此对于这个游戏的分析表明没有经典的隐变量理论（局域性理论）可以解释量子纠缠所带来的一系列的相关性（一方的测量可以非局域性地影响另一方的测量结果）和后果（比经典更优的策略）。\n附录 参考文献 版权信息 本文原载于 quantum51.top，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n原文注释：后面可以在附录添加这个的几何推导\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n原文注释：CHSH游戏的规则是：当 $x=y=1$时，Alice和Bob的回应 $a和b$要不一样（$a\\oplus b=1$）才能获胜，剩下的情况需要 $a和b要一样$（$a\\oplus b=0$）才能获胜\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n原文注释：这里总是认为我们的策略总是让Alice和Bob的获胜概率大于他们失败的概率，因为就算是不改变Bell态，获胜的概率都是75%\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n原文注释：why？\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n原文注释：解释放在附录里面\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n原文注释：详细定义见附录\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n原文注释：上式中$|C|^2 = |C^2|$对于一般的normal算符是成立的（具体证明在附录）\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n原文注释：CHSH游戏是可以在实验上实现的\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-04-16T16:39:44+08:00","permalink":"http://localhost:1313/2025/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87chapter-2/","title":"毕业论文|chapter 2"},{"content":"量子纠缠的早期视角 EPR佯谬 一般的纠缠态 一个最经典的纠缠态的例子就是：在计算基矢 (Computational basis) 中，如果对于一个两个量子比特的系统（包含了两个子系统 Alice 和 Bob），总状态是：\n$$ \\ket{\\psi} = \\frac{1}{\\sqrt{2}}(\\ket{0}\\ket{1} + \\ket{1}\\ket{0}) $$\n其中 $\\ket{0}\\ket{1}$ 表示一个复合系统，等价于 $\\ket{0} \\otimes \\ket{1}$，左边代表系统 I 的状态，右边表示系统 II 的状态。\n那么对于这个系统，如果测量到 A 系统的状态是 $\\ket{0}$，那么 B 系统的状态就是 $\\ket{1}$；另一种情况也是一样的，这个形式与式（8）具有相似之处。\n所谓“纠缠”就是：对一个系统的观测结果会瞬间影响另一个系统的状态，而且这种影响是非局域性的（无论两个系统相距多远），这就像一种“幽灵般的超距作用”。\nEPR佯谬 对于纠缠这个概念，最早的启发来自 Einstein 与其合作者在 1935 年发表的论文：\n\u0026ldquo;Can Quantum-Mechanical Description of Physical Reality Be Considered Complete?\u0026rdquo;\n—— 量子力学中对物理现实的描述是完整的吗？\n他们认为量子力学的表述是不完备的，并提出了一个纠缠系统的思考实验。他们首先定义了“物理现实中的元素”（Elements of Physical Reality）：\n定义：\n如果我们可以在不干扰系统的前提下，准确预测该系统中某一物理量的值，那么就存在一个物理现实的元素对应于这个物理量。\n然后他们将这个标准应用到一个复合量子系统：两个相距很远的粒子（编号为 1 和 2），其状态由如下纠缠波函数描述：\n$$ \\psi(x_1, x_2, p_1, p_2) = \\delta(x_1 - x_2 - L)\\delta(p_1 + p_2) $$\n其中 $\\delta$ 并不是真正的 Dirac delta 函数，而是一个归一化的尖峰函数；$L$ 是一个相对于粒子间相互作用而言非常大的距离。\n这个波函数的物理意义是：\n两个粒子之间的距离几乎是 $L$； 总动量几乎为 $0$； 而且 $x_1 - x_2$ 和 $p_1 + p_2$ 是可同时观测的对易算符。 💡 注：你也可以在这里插入一个 delta 函数图像来辅助理解。\n对于这个状态来说，我们对单个粒子的状态（位置或动量）是一无所知的；我们只知道两个粒子之间的差值（距离、动量和）可以确定。\n如果我们测量粒子 1 的位置 $x_1$，我们可以准确预测粒子 2 的位置：$x_2 = x_1 - L$。\n根据 EPR 的论点：由于两个粒子此时不再相互作用，粒子 1 的测量不会干扰粒子 2，因此 $x_2$ 对应着一个物理现实元素。\n同理，如果我们测量粒子 1 的动量 $p_1$，就能预测粒子 2 的动量：$p_2 = -p_1$，因此 $p_2$ 也对应一个物理现实元素。\n但是，根据量子力学的基本原理（不确定性原理）：\n$$ \\Delta x \\cdot \\Delta p \\geq \\frac{\\hbar}{2} $$\n当粒子的位置被精确测量（$\\Delta x = 0$）时，其动量的测量精度就必须变差（$\\Delta p \\to \\infty$），所以不能同时确定位置与动量。\n因此，EPR 论文指出：我们从测量粒子 1 就可以同时“知道”粒子 2 的位置和动量，这与量子力学的不确定性原理矛盾。\n🧠 结论：这说明量子力学对物理现实的描述是不完备的。\nEPR 因此推测：存在某些“隐藏变量”（目前未知），使得这些物理量实际上是可以同时确定的。这就是“隐变量理论”（Hidden Variables Theory）的雏形。论文并未给出这种理论的构造，但为后来的 Bell 不等式与实验验证奠定了基础。\n附录 参考文献 版权信息 本文原载于 quantum51.top，遵循 CC BY-NC-SA 4.0 协议，复制请保留原文出处。\n","date":"2025-04-16T16:38:41+08:00","permalink":"http://localhost:1313/2025/%E6%AF%95%E4%B8%9A%E8%AE%BA%E6%96%87chapter-1/","title":"毕业论文|chapter 1"}]